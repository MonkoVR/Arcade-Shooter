<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Shooter Game - Main Menu & Modes</title>
    
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            color: white;
            font-family: Arial, sans-serif;
        }

        canvas {
            background-color: #000;
            border: 2px solid #fff;
        }

        #gameContainer {
            position: relative;
            width: 600px;
            height: 400px;
        }

        #mainMenu, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        #gameOverScreen {
            display: none;
        }

        .menuButton {
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .menuButton:hover {
            background-color: #0056b3;
        }

        /* RED SHAKING BUTTON */
        .impossibleButton {
            background-color: #ff0000 !important;
            animation: shake 0.2s infinite;
        }

        @keyframes shake {
            0% { transform: translate(0px, 0px); }
            25% { transform: translate(2px, -2px); }
            50% { transform: translate(-2px, 2px); }
            75% { transform: translate(2px, 2px); }
            100% { transform: translate(0px, 0px); }
        }

        h1, h2 {
            margin: 0;
        }
    </style>
</head>
<body>

    <div id="gameContainer">

        <!-- MAIN MENU -->
        <div id="mainMenu">
            <h1>Arcade Shooter</h1>
            <button class="menuButton" onclick="startGame('easy')">Play (Easy Mode)</button>
            <button class="menuButton" onclick="startGame('hard')">Play (Hard Mode)</button>
            <button class="menuButton impossibleButton" onclick="startGame('impossible')">HUMANLY IMPOSSIBLE</button>
        </div>

        <!-- GAME CANVAS -->
        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <!-- GAME OVER SCREEN -->
        <div id="gameOverScreen">
            <h1 style="color: #ff0000;">GAME OVER</h1>
            <h2 id="finalScoreText">Final Score: 0</h2>
            <button class="menuButton" onclick="showMainMenu()">Retry / Change Mode</button>
        </div>
    </div>

    <script>
        // ---- SOUND SYSTEM ----
        function playSound(frequency, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

                oscillator.start(audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {}
        }

        function playShootSound() { playSound(1000, 0.05); }
        function playDamageSound() { playSound(300, 0.2); }

        function playGameOverSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            oscillator.connect(audioContext.destination);
            oscillator.frequency.setValueAtTime(500, audioContext.currentTime);
            oscillator.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mainMenu = document.getElementById('mainMenu');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreText = document.getElementById('finalScoreText');

        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;

        let score = 0;
        let gameOver = false;
        let enemySpawnInterval;
        let gameMode = 'hard';
        let spawnRateMultiplier = 1;
        const MAX_HEALTH = 100;
        let playerHealth = MAX_HEALTH;

        // --- GAME CLASSES ---
        class Square {
            constructor(x, y, size, speed, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.speed = speed;
                this.color = color;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
            isColliding(other) {
                return (
                    this.x < other.x + other.size &&
                    this.x + this.size > other.x &&
                    this.y < other.y + other.size &&
                    this.y + this.size > other.y
                );
            }
        }

        class PlayerShip extends Square {
            constructor(x, y, size, speed, color) {
                super(x, y, size, speed, color);
                this.originalColor = color;
                this.hitColor = '#ff4500';
                this.isHit = false;
                this.hitTimer = 0;
            }
            draw() {
                if (this.isHit) {
                    ctx.fillStyle = this.hitColor;
                    this.hitTimer--;
                    if (this.hitTimer <= 0) {
                        this.isHit = false;
                        this.color = this.originalColor;
                    }
                } else {
                    ctx.fillStyle = this.color;
                }

                ctx.fillRect(this.x, this.y, this.size, this.size);

                const healthBarWidth = this.size;
                const healthBarHeight = 4;
                const healthPercentage = playerHealth / MAX_HEALTH;

                ctx.fillStyle = '#555';
                ctx.fillRect(this.x, this.y - 6, healthBarWidth, healthBarHeight);

                ctx.fillStyle =
                    healthPercentage > 0.5 ? '#00ff00' :
                    healthPercentage > 0.25 ? '#ffa500' : '#ff0000';

                ctx.fillRect(this.x, this.y - 6, healthBarWidth * healthPercentage, healthBarHeight);
            }
            onHit() {
                this.isHit = true;
                this.hitTimer = 10;
            }
        }

        const player = new PlayerShip(50, CANVAS_HEIGHT / 2 - 15, 30, 5, '#00ff00');
        let playerBullets = [];
        let spacePressed = false;
        const BULLET_SIZE = 5;
        const BULLET_SPEED = 7;

        function shoot() {
            if (gameOver || spacePressed) return;

            playerBullets.push(new Square(
                player.x + player.size,
                player.y + player.size / 2 - BULLET_SIZE / 2,
                BULLET_SIZE,
                BULLET_SPEED,
                '#ffffff'
            ));

            playShootSound();
            spacePressed = true;
        }

        class Projectile extends Square {
            constructor(x, y, targetX, targetY, speed, color, isSeeking = false) {
                super(x, y, 5, speed, color);
                if (isSeeking) {
                    const dx = targetX - x;
                    const dy = targetY - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    this.velocityX = (dx / dist) * speed;
                    this.velocityY = (dy / dist) * speed;
                } else {
                    this.velocityX = speed;
                    this.velocityY = 0;
                }
            }
            updateMovement() {
                this.x += this.velocityX;
                this.y += this.velocityY;
            }
        }

        // --- ENEMIES ---
        let enemies = [];
        let enemyProjectiles = [];
        let enemyBaseSpeed = 2;
        const ENEMY_SIZE_MIN = 15;
        const ENEMY_SIZE_MAX = 30;

        class TankEnemy extends Square {
            constructor(x, y, size, speed, color) {
                super(x, y, size, speed * 0.7, color);
                this.health = 2;
            }
        }

        class ShootingEnemy extends Square {
            constructor(x, y, size, speed, color) {
                super(x, y, size, speed, color);
                this.health = 1;
                this.shootInterval = setInterval(() => this.shoot(),
                    gameMode === 'easy'
                        ? 2500 + Math.random() * 1500
                        : 1200 + Math.random() * 800
                );
            }
            shoot() {
                if (gameOver) return;

                enemyProjectiles.push(
                    new Projectile(
                        this.x,
                        this.y + this.size / 2,
                        player.x + player.size / 2,
                        player.y + player.size / 2,
                        4,
                        '#ff4500',
                        true
                    )
                );
            }
            destroy() { clearInterval(this.shootInterval); }
        }

        class JumpingEnemy extends Square {
            constructor(x, y, size, speed, color) {
                super(x, y, size, speed, color);
                this.health = 1;
                this.verticalSpeed = (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1);
            }
            updateMovement() {
                this.x -= this.speed;
                this.y += this.verticalSpeed;
                if (this.y < 0 || this.y + this.size > CANVAS_HEIGHT)
                    this.verticalSpeed *= -1;
            }
        }

        function spawnEnemy() {
            if (gameOver) return;

            const size = Math.random() * (ENEMY_SIZE_MAX - ENEMY_SIZE_MIN) + ENEMY_SIZE_MIN;
            const y = Math.random() * (CANVAS_HEIGHT - size);
            const speed = Math.random() * enemyBaseSpeed + enemyBaseSpeed;

            const r = Math.random();
            if (r < 0.35)
                enemies.push(Object.assign(new Square(CANVAS_WIDTH, y, size, speed, '#ff0000'), { health: 1 }));
            else if (r < 0.7)
                enemies.push(new ShootingEnemy(CANVAS_WIDTH, y, size, speed, '#ffa500'));
            else if (r < 0.85)
                enemies.push(new TankEnemy(CANVAS_WIDTH, y, size * 1.2, speed, '#0000ff'));
            else
                enemies.push(new JumpingEnemy(CANVAS_WIDTH, y, size, speed, '#8a2be2'));
        }

        // --- INPUT ---
        const keys = { up: false, down: false, left: false, right: false };

        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') keys.down = true;
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            if (e.key === ' ' && !spacePressed) shoot();
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') keys.down = false;
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
            if (e.key === ' ') spacePressed = false;
        });

        function updatePlayerPosition() {
            if (keys.up && player.y > 0) player.y -= player.speed;
            if (keys.down && player.y < CANVAS_HEIGHT - player.size) player.y += player.speed;
            if (keys.left && player.x > 0) player.x -= player.speed;
            if (keys.right && player.x < CANVAS_WIDTH - player.size) player.x += player.speed;
        }

        function takeDamage(amount) {
            if (gameOver) return;
            playerHealth -= amount;
            player.onHit();
            playDamageSound();
            if (playerHealth <= 0) endGame();
        }

        function updateGameArea() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            if (gameOver) return;

            updatePlayerPosition();
            player.draw();

            // bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const b = playerBullets[i];
                b.x += b.speed;
                b.draw();
                if (b.x > CANVAS_WIDTH) playerBullets.splice(i, 1);
            }

            // enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (typeof e.updateMovement === 'function') e.updateMovement();
                else e.x -= e.speed;

                e.draw();

                if (player.isColliding(e)) {
                    playerHealth = 0;
                    endGame();
                    return;
                }

                if (e.x + e.size < 0) {
                    if (typeof e.destroy === 'function') e.destroy();
                    enemies.splice(i, 1);
                    takeDamage(10);
                }
            }

            // enemy bullets
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const p = enemyProjectiles[i];
                p.updateMovement();
                p.draw();

                if (player.isColliding(p)) {
                    takeDamage(5);
                    enemyProjectiles.splice(i, 1);
                }

                if (
                    p.x < 0 || p.x > CANVAS_WIDTH ||
                    p.y < 0 || p.y > CANVAS_HEIGHT
                ) enemyProjectiles.splice(i, 1);
            }

            checkCollisions();
            displayScore();
            requestAnimationFrame(updateGameArea);
        }

        function checkCollisions() {
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const b = playerBullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.isColliding(e)) {
                        e.health--;
                        playerBullets.splice(i, 1);
                        if (e.health <= 0) {
                            score += 10;
                            if (typeof e.destroy === 'function') e.destroy();
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
        }

        function displayScore() {
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText('Score: ' + score, 10, 20);
            ctx.fillText('Mode: ' + gameMode, 10, 40);
        }

        function endGame() {
            if (gameOver) return;
            gameOver = true;

            playGameOverSound();
            clearInterval(enemySpawnInterval);

            enemies.forEach(e => {
                if (typeof e.destroy === 'function') e.destroy();
            });

            finalScoreText.textContent = 'Final Score: ' + score;
            gameOverScreen.style.display = 'flex';
        }

        // --- MENU / GAME START ---
        function showMainMenu() {
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'none';
            mainMenu.style.display = 'flex';
        }

        function startGame(mode) {
            gameMode = mode;

            if (mode === 'easy') {
                spawnRateMultiplier = 2;
                enemyBaseSpeed = 1.5;
            }
            else if (mode === 'hard') {
                spawnRateMultiplier = 0.7;
                enemyBaseSpeed = 2;
            }
            else if (mode === 'impossible') {
                spawnRateMultiplier = 0.01;  // 4Ã— as many enemies
                enemyBaseSpeed = 50;          // MUCH faster enemies
            }

            mainMenu.style.display = 'none';
            gameOverScreen.style.display = 'none';
            canvas.style.display = 'block';

            score = 0;
            playerHealth = MAX_HEALTH;
            enemies = [];
            enemyProjectiles = [];
            playerBullets = [];
            gameOver = false;

            player.x = 50;
            player.y = CANVAS_HEIGHT / 2 - 15;
            player.isHit = false;

            enemySpawnInterval = setInterval(spawnEnemy,
                (1500 + Math.random() * 1000) * spawnRateMultiplier
            );

            requestAnimationFrame(updateGameArea);
        }

        showMainMenu();
    </script>
</body>
</html>
